┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                    支付主流程                                            │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌──────────┐
    │  业务方   │ (如：视频服务发起投币请求)
    └────┬─────┘
         │
         │ POST /api/v1/pay/execute
         │ {request_id, user_id, amount, product_type, product_id}
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤①  【幂等校验 - 第一次】                                                             │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: pay_service.go:56-69                                                         │
│                                                                                         │
│  existingOrder, err := s.orderRepo.GetByRequestID(ctx, req.RequestID)                   │
│  if existingOrder != nil {                                                              │
│      return &PayResponse{OrderNo: existingOrder.OrderNo, ...}  // 直接返回已有结果       │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 问题：网络抖动/用户重复点击 导致同一请求发送多次                                     │   │
│  │ 后果：如果不做幂等，用户可能被扣多次钱！                                            │   │
│  │ 方案：用 request_id 作为唯一标识，已处理的请求直接返回结果                          │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ request_id 不存在，继续处理
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤②  【获取分布式锁】                                                                 │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: pay_service.go:71-77, distributed_lock.go                                    │
│                                                                                         │
│  payLock := lock.NewPayLock(s.redisClient, req.UserID, req.RequestID)                   │
│  err = payLock.Lock(ctx, 100*time.Millisecond, 30)  // 重试30次，每次间隔100ms          │
│  defer payLock.Unlock(ctx)                                                              │
│                                                                                         │
│  【Redis命令】                                                                           │
│  SET pay:lock:user:{userID}:{requestID} {uuid} NX EX 30                                 │
│       │                                    │    │  │                                    │
│       │                                    │    │  └─ 30秒后自动过期，防止死锁           │
│       │                                    │    └─ 只有key不存在时才设置                 │
│       │                                    └─ 锁持有者标识，释放时验证                   │
│       └─ 锁的key，按用户+请求维度                                                       │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 问题：并发请求同时进入，可能同时读到相同余额，导致超扣                               │   │
│  │                                                                                  │   │
│  │   时间线（无锁）:                                                                 │   │
│  │   goroutine1: 读余额=100 ─────────────────────────> 扣100 ──> 余额=0             │   │
│  │   goroutine2:      读余额=100 ─────────────────────────> 扣100 ──> 余额=-100 ❌  │   │
│  │                                                                                  │   │
│  │   时间线（有锁）:                                                                 │   │
│  │   goroutine1: 获锁 ──> 读余额=100 ──> 扣100 ──> 余额=0 ──> 释放锁                 │   │
│  │   goroutine2:              等待...              获锁 ──> 读余额=0 ──> 余额不足 ✅ │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 获取锁成功
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤③  【幂等校验 - 第二次（Double Check）】                                            │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: pay_service.go:79-90                                                         │
│                                                                                         │
│  // 获取锁后再次检查，防止在等待锁的过程中订单已被其他请求创建                             │
│  existingOrder, err = s.orderRepo.GetByRequestID(ctx, req.RequestID)                    │
│  if existingOrder != nil {                                                              │
│      return &PayResponse{OrderNo: existingOrder.OrderNo, ...}                           │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 问题：两个请求同时通过第一次幂等校验，都在等锁                                       │   │
│  │                                                                                  │   │
│  │   goroutine1: 幂等校验通过 ──> 获锁成功 ──> 创建订单                              │   │
│  │   goroutine2: 幂等校验通过 ──> 等待锁... ──> 获锁成功 ──> ???                     │   │
│  │                                                                                  │   │
│  │ 如果不做第二次检查，goroutine2 会再创建一次订单！                                   │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 确认是新请求
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤④  【预检查余额】                                                                   │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: pay_service.go:92-99                                                         │
│                                                                                         │
│  account, err := s.accountRepo.GetOrCreate(ctx, req.UserID)                             │
│  if account.Balance < req.Amount {                                                      │
│      return nil, errors.New("余额不足")                                                 │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 作用：快速失败（Fail Fast）                                                       │   │
│  │ 在进入复杂的事务处理前，先做简单校验，避免无谓的资源消耗                              │   │
│  │ 注意：这只是预检查，真正的余额校验在事务内用乐观锁保证                               │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 余额充足
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑤  【创建订单（状态: CREATED）】                                                    │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: pay_service.go:101-116                                                       │
│                                                                                         │
│  orderNo := idgen.GenerateOrderNo()  // 雪花算法生成全局唯一订单号                       │
│  expiredAt := time.Now().Add(30 * time.Minute)  // 30分钟后过期                         │
│                                                                                         │
│  order := &model.PayOrder{                                                              │
│      OrderNo:     orderNo,                                                              │
│      RequestID:   req.RequestID,   // 关联幂等键                                        │
│      UserID:      req.UserID,                                                           │
│      Amount:      req.Amount,                                                           │
│      Status:      "CREATED",       // 初始状态                                          │
│      ExpiredAt:   expiredAt,       // 过期时间                                          │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ request_id 唯一索引：数据库层面兜底，即使代码有bug，重复插入也会失败                  │   │
│  │ expired_at：为后续的超时关闭任务提供依据                                            │   │
│  │ 雪花算法：保证分布式环境下订单号全局唯一且有序                                       │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑥  【核心事务：扣款 + 记流水 + 更新状态 + 写消息表】                                 │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: pay_service.go:118-175                                                       │
│                                                                                         │
│  ┌───────────────────────────── MySQL 事务开始 ─────────────────────────────┐          │
│  │                                                                          │          │
│  │  ⑥-1. 创建订单记录                                                       │          │
│  │       INSERT INTO pay_order (...) VALUES (...)                           │          │
│  │                                                                          │          │
│  │  ⑥-2. 订单状态: CREATED → PAYING                                        │          │
│  │       UPDATE pay_order SET status='PAYING' WHERE order_no=? AND status='CREATED'    │
│  │                                                                          │          │
│  │  ⑥-3. 扣款（乐观锁）                                              │          │
│  │       UPDATE account                                                     │          │
│  │       SET balance = balance - 100,                                       │          │
│  │           version = version + 1          ← 版本号+1                      │          │
│  │       WHERE user_id = ?                                                  │          │
│  │         AND balance >= 100               ← 再次校验余额                   │          │
│  │         AND version = ?                  ← 版本号必须匹配                 │          │
│  │                                                                          │          │
│  │  ⑥-4. 记录账户流水                                                       │          │
│  │       INSERT INTO account_transaction (                                  │          │
│  │           user_id, order_no, amount, type,                               │          │
│  │           balance_before, balance_after  ← 记录变动前后余额               │          │
│  │       )                                                                  │          │
│  │                                                                          │          │
│  │  ⑥-5. 订单状态: PAYING → PAID                                           │          │
│  │       UPDATE pay_order SET status='PAID', paid_at=NOW()                  │          │
│  │       WHERE order_no=? AND status='PAYING'                               │          │
│  │                                                                          │          │
│  │  ⑥-6. 写入 Outbox 消息表（关键！）                                        │          │
│  │       INSERT INTO outbox_message (topic, message_key, payload, status)   │          │
│  │       VALUES ('pay_result', orderNo, '{...}', 'PENDING')                 │          │
│  │                                                                          │          │
│  └───────────────────────────── MySQL 事务提交 ─────────────────────────────┘          │
│                                                                                         │
│  【解决的问题 - 乐观锁】                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 问题：分布式锁只能挡住同一个 request_id 的重复请求                                 │   │
│  │      但同一用户可能同时发起多个不同的支付请求                                       │   │
│  │                                                                                  │   │
│  │ 场景：用户余额100，同时发起两笔50元支付                                            │   │
│  │   请求A (request_id=a): 读版本号=1, 余额=100                                     │   │
│  │   请求B (request_id=b): 读版本号=1, 余额=100                                     │   │
│  │   请求A: UPDATE ... WHERE version=1 → 成功，version变为2                         │   │
│  │   请求B: UPDATE ... WHERE version=1 → 失败！版本号不匹配                          │   │
│  │                                                                                  │   │
│  │ 乐观锁 = CAS（Compare And Swap）思想：先比较再修改                                 │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                         │
│  【解决的问题 - Outbox Pattern】                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 问题：如何保证"扣款成功"和"通知业务方"的一致性？                                    │   │
│  │                                                                                  │   │
│  │ 错误做法：                                                                        │   │
│  │   tx.Commit()                      // 事务提交                                    │   │
│  │   kafka.Send("pay_result", ...)    // 发消息                                      │   │
│  │   // 如果这里服务崩溃，消息就丢了！                                                │   │
│  │                                                                                  │   │
│  │ Outbox 做法：                                                                     │   │
│  │   tx.Begin()                                                                      │   │
│  │   ... 扣款、记流水 ...                                                            │   │
│  │   INSERT INTO outbox_message (...)  // 消息也写数据库                             │   │
│  │   tx.Commit()                       // 要么全成功，要么全失败                       │   │
│  │                                                                                  │   │
│  │ 消息发送由独立的异步任务负责（见步骤⑧）                                            │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                         │
│  【解决的问题 - 状态机】                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 订单状态流转有严格的规则：                                                         │   │
│  │                                                                                  │   │
│  │   CREATED → PAYING → PAID                                                        │   │
│  │                                                                                  │   │
│  │ 每次更新状态都要校验当前状态：                                                      │   │
│  │   UPDATE ... WHERE status = 'CREATED'  // 只有CREATED才能变成PAYING               │   │
│  │   UPDATE ... WHERE status = 'PAYING'   // 只有PAYING才能变成PAID                  │   │
│  │                                                                                  │   │
│  │ 如果状态不对，RowsAffected=0，说明有并发冲突，事务回滚                              │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 事务提交成功
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑦  【释放分布式锁 & 返回结果】                                                      │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: distributed_lock.go:98-112                                                   │
│                                                                                         │
│  // 使用 Lua 脚本保证原子性：检查+删除                                                   │
│  script := `                                                                            │
│      if redis.call("GET", KEYS[1]) == ARGV[1] then                                      │
│          return redis.call("DEL", KEYS[1])                                              │
│      else                                                                               │
│          return 0                                                                       │
│      end                                                                                │
│  `                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 问题：如何安全释放锁，不误删别人的锁？                                              │   │
│  │                                                                                  │   │
│  │ 错误做法：                                                                        │   │
│  │   redis.DEL(lockKey)  // 直接删除                                                 │   │
│  │   // 可能删除的是别人持有的锁！                                                    │   │
│  │                                                                                  │   │
│  │ 场景：                                                                            │   │
│  │   时刻1: A 获取锁，锁30秒过期                                                     │   │
│  │   时刻31: A 处理太慢，锁自动过期                                                   │   │
│  │   时刻32: B 获取锁成功                                                            │   │
│  │   时刻33: A 处理完成，执行 DEL → 删掉了 B 的锁！                                   │   │
│  │                                                                                  │   │
│  │ 正确做法：用 Lua 脚本，先验证 value 是自己的，再删除                                │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ return {order_no, status: "PAID", amount, message: "支付成功"}
         ▼
    ┌──────────┐
    │  业务方   │  收到支付成功响应
    └──────────┘

┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                               Outbox 消息发送流程                                        │
│                              （独立 goroutine 运行）                                     │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌───────────────────┐
    │  OutboxSender     │  每 100ms 执行一次
    │  定时任务启动      │
    └─────────┬─────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑧-1  【扫描待发送消息】                                                             │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: outbox_sender.go:55-67                                                       │
│                                                                                         │
│  SELECT * FROM outbox_message                                                           │
│  WHERE status = 'PENDING'                                                               │
│  ORDER BY created_at ASC                                                                │
│  LIMIT 100                                                                              │
│                                                                                         │
│  【为什么这样设计】                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ - 轮询间隔100ms：平衡实时性和数据库压力                                            │   │
│  │ - 按创建时间排序：保证消息顺序                                                     │   │
│  │ - 限制100条：避免一次处理太多导致超时                                              │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
              │
              │ 有待发送的消息
              ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑧-2  【发送到 Kafka】                                                               │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: outbox_sender.go:69-93                                                       │
│                                                                                         │
│  for _, msg := range messages {                                                         │
│      err := kafka.Send(msg.Topic, msg.MessageKey, msg.Payload)                          │
│                                                                                         │
│      if err == nil {                                                                    │
│          // 发送成功，更新状态为 SENT                                                    │
│          UPDATE outbox_message SET status='SENT' WHERE id=?                             │
│      } else {                                                                           │
│          // 发送失败，增加重试次数                                                       │
│          UPDATE outbox_message SET retry_count=retry_count+1 WHERE id=?                 │
│                                                                                         │
│          if retry_count >= max_retry {                                                  │
│              // 超过最大重试次数，标记为失败，人工介入                                    │
│              UPDATE outbox_message SET status='FAILED' WHERE id=?                       │
│          }                                                                              │
│      }                                                                                  │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 消息可靠投递保证：                                                                │   │
│  │   - 发送成功 → 更新状态，不会重复发                                               │   │
│  │   - 发送失败 → 重试，直到成功或达到上限                                            │   │
│  │   - 服务重启 → 消息还在数据库里，重启后继续发                                       │   │
│  │                                                                                  │   │
│  │ 注意：消费方必须做幂等！因为可能重复发送（发成功但更新状态失败的情况）                 │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌───────────────────┐
    │      Kafka        │
    │   pay_result 主题 │
    └─────────┬─────────┘
              │
              ▼
    ┌───────────────────┐
    │     业务方消费     │  得知支付成功，更新视频投币数等
    └───────────────────┘



┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                              订单超时关闭流程                                            │
│                             （独立 goroutine 运行）                                      │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌───────────────────┐
    │ OrderTimeoutJob   │  每 10 秒执行一次
    │  定时任务启动      │
    └─────────┬─────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑨-1  【查询超时订单】                                                               │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: order_timeout.go:56-74                                                       │
│                                                                                         │
│  SELECT * FROM pay_order                                                                │
│  WHERE status = 'CREATED'                                                               │
│    AND expired_at < NOW()           ← 已过期                                            │
│  LIMIT 100                                                                              │
│                                                                                         │
│  【设计说明】                                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ - 只处理 CREATED 状态的订单                                                       │   │
│  │ - PAYING 状态的订单不能直接关闭（可能正在扣款中）                                    │   │
│  │ - expired_at 在创建订单时设置（当前时间 + 30分钟）                                  │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
              │
              │ 找到超时订单
              ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑨-2  【关闭订单】                                                                   │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│                                                                                         │
│  for _, order := range expiredOrders {                                                  │
│      UPDATE pay_order                                                                   │
│      SET status = 'CLOSED'                                                              │
│      WHERE order_no = ?                                                                 │
│        AND status = 'CREATED'    ← 再次校验状态，防止并发问题                            │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 场景：用户创建订单后30分钟未支付                                                   │   │
│  │                                                                                  │   │
│  │ 如果不关闭：                                                                      │   │
│  │   - 订单永远挂在那里                                                              │   │
│  │   - 用户后续查询会很困惑                                                          │   │
│  │   - 数据库积累大量无效数据                                                         │   │
│  │                                                                                  │   │
│  │ 关闭后：                                                                          │   │
│  │   - 订单状态清晰：CLOSED = 超时未支付                                              │   │
│  │   - 用户想支付需要重新创建订单                                                     │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘



┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                    退款流程                                              │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    ┌──────────┐
    │  业务方   │  发起退款请求
    └────┬─────┘
         │
         │ POST /api/v1/refund/execute
         │ {request_id, order_no, reason}
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑩-1  【校验订单状态】                                                               │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: refund_service.go:54-65                                                      │
│                                                                                         │
│  order := GetByOrderNo(req.OrderNo)                                                     │
│  if order.Status != "PAID" {                                                            │
│      return error("订单状态不允许退款")                                                  │
│  }                                                                                      │
│                                                                                         │
│  【校验规则】                                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 只有 PAID 状态的订单才能退款：                                                     │   │
│  │   - CREATED/PAYING → 还没支付成功，不需要退款                                      │   │
│  │   - CLOSED/CANCELLED → 已关闭，没扣过钱                                           │   │
│  │   - REFUNDING/REFUNDED → 已经在退款或已退款                                       │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 订单状态为 PAID
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑩-2  【幂等校验 - 检查是否已退款】                                                   │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: refund_service.go:67-77                                                      │
│                                                                                         │
│  existingTrans := GetByUserIDAndOrderNo(order.UserID, req.OrderNo)                      │
│  if existingTrans != nil && existingTrans.Type == "REFUND" {                            │
│      return {status: "REFUNDED", message: "已退款，请勿重复操作"}                         │
│  }                                                                                      │
│                                                                                         │
│  【解决的问题】                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 通过流水记录判断是否已退款，防止重复退款                                            │   │
│  │ 这里用流水而不是订单状态，是因为流水更精确（记录了实际的资金变动）                     │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 未退款
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑩-3  【获取分布式锁（按订单维度）】                                                  │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: refund_service.go:79-89                                                      │
│                                                                                         │
│  lockKey := "refund:lock:order:{orderNo}"                                               │
│  refundLock := NewDistributedLock(lockKey, requestID, 30s)                              │
│  refundLock.Lock(...)                                                                   │
│                                                                                         │
│  【为什么按订单维度加锁】                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │ 支付时按用户维度加锁：防止同一用户的多个支付请求并发                                  │   │
│  │ 退款时按订单维度加锁：防止同一订单的多个退款请求并发                                  │   │
│  │                                                                                  │   │
│  │ 不同维度，不同场景                                                                │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 获取锁成功
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑩-4  【Double Check 订单状态】                                                      │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: refund_service.go:91-103                                                     │
│                                                                                         │
│  order = GetByOrderNo(req.OrderNo)  // 重新查询                                         │
│  if order.Status != "PAID" {                                                            │
│      // 可能在等待锁的过程中已被其他请求退款                                              │
│      if order.Status == "REFUNDED" {                                                    │
│          return {message: "已退款，请勿重复操作"}                                        │
│      }                                                                                  │
│      return error("订单状态不允许退款")                                                  │
│  }                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ 确认可以退款
         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│  步骤⑩-5  【核心事务：退款到账 + 记流水 + 更新状态 + 写消息】                              │
│  ─────────────────────────────────────────────────────────────────────────────────────  │
│  代码位置: refund_service.go:107-152                                                    │
│                                                                                         │
│  ┌───────────────────────────── MySQL 事务开始 ─────────────────────────────┐          │
│  │                                                                          │          │
│  │  1. 订单状态: PAID → REFUNDING                                           │          │
│  │                                                                          │          │
│  │  2. 账户加钱                                                              │          │
│  │     UPDATE account SET balance = balance + {amount}                      │          │
│  │                                                                          │          │
│  │  3. 记录退款流水                                                          │          │
│  │     INSERT INTO account_transaction (type='REFUND', amount=+100, ...)    │          │
│  │                                                                          │          │
│  │  4. 订单状态: REFUNDING → REFUNDED                                       │          │
│  │                                                                          │          │
│  │  5. 写入 Outbox 消息（通知业务方退款成功）                                  │          │
│  │                                                                          │          │
│  └───────────────────────────── MySQL 事务提交 ─────────────────────────────┘          │
└─────────────────────────────────────────────────────────────────────────────────────────┘
         │
         │ return {status: "REFUNDED", message: "退款成功"}
         ▼
    ┌──────────┐
    │  业务方   │  收到退款成功响应
    └──────────┘


┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                              订单状态机完整流转                                           │
└─────────────────────────────────────────────────────────────────────────────────────────┘

                                ┌──────────────┐
                                │   CREATED    │
                                │   (待支付)    │
                                └──────┬───────┘
                                       │
               ┌───────────────────────┼───────────────────────┐
               │                       │                       │
               ▼                       ▼                       ▼
        ┌──────────────┐        ┌──────────────┐        ┌──────────────┐
        │   PAYING     │        │   CLOSED     │        │  CANCELLED   │
        │   (支付中)    │        │  (超时关闭)   │        │  (用户取消)   │
        └──────┬───────┘        └──────────────┘        └──────────────┘
               │                    终态 ✓                  终态 ✓
               │
        ┌──────┴──────┐
        │             │
        ▼             ▼
 ┌──────────────┐ ┌──────────────┐
 │    PAID      │ │   FAILED     │
 │  (支付成功)   │ │  (支付失败)   │
 └──────┬───────┘ └──────────────┘
        │              终态 ✓
        │
        ▼
 ┌──────────────┐
 │  REFUNDING   │
 │  (退款中)     │
 └──────┬───────┘
        │
        ▼
 ┌──────────────┐
 │   REFUNDED   │
 │   (已退款)    │
 └──────────────┘
     终态 ✓


  状态流转规则（代码实现）:
  ─────────────────────────────────────────────
  ValidStatusTransitions = {
      "CREATED":   ["PAYING", "CLOSED", "CANCELLED"],
      "PAYING":    ["PAID", "FAILED"],
      "PAID":      ["REFUNDING"],
      "REFUNDING": ["REFUNDED"],
  }

  每次状态变更都会校验：
  UPDATE ... WHERE status = {当前状态}
  如果 RowsAffected = 0，说明状态已变，拒绝操作



各步骤解决的问题汇总表
步骤	    组件/技术	          解决的问题	                如果不做会怎样
①	    幂等校验(request_id)	重复请求	                   用户被多次扣款
②	    分布式锁(Redis)	        并发请求同时操作	            余额可能被超扣
③	    Double Check	       等锁期间的并发	               锁内重复创建订单
④	    预检查余额	            快速失败	                    无谓地进入事务处理
⑤	    雪花算法ID	            订单号全局唯一	                分布式下ID冲突
⑥-扣款	乐观锁(version)	        同用户多请求并发扣款	          余额可能为负
⑥-流水	流水表	                对账、审计	                    出问题无法追溯
⑥-状态机	状态校验	        非法状态流转	                已关闭订单被支付
⑥-Outbox	消息表	           DB与消息一致性	               扣款成功但通知丢失
⑦	    Lua脚本释放锁	        误删别人的锁	                锁机制失效
⑧	    异步发送+重试	        消息可靠投递	                业务方收不到通知
⑨	    超时关闭任务	        僵尸订单	                    数据库积累无效数据
⑩	    退款流程	           资金退回	                       用户投诉、资损